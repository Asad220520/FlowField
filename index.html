<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Flow Field — Gestures (Sharp Geometry + Snap Explosion)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0d10;color:#cfd3dc;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh}
  .hint{
    position:fixed;left:50%;bottom:12px;transform:translateX(-50%);
    padding:.6rem .9rem;border-radius:999px;background:rgba(18,22,28,.55);backdrop-filter:blur(8px);
    box-shadow:0 6px 30px rgba(0,0,0,.35);font-size:.9rem;letter-spacing:.2px;user-select:none;opacity:.9
  }
  @media (min-width:900px){.hint{bottom:18px}}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint" id="hint">1 палец — расслабленно · 2 пальца — сбор (удержи ≥10с → взрыв) · 3+ пальцев — фигуры</div>

<script>
(()=> {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
  // ---------- ТОНКАЯ НАСТРОЙКА ----------
  const CFG = {
    PARTICLES: 2200,            // автоскейлится ниже
    LINE_WIDTH: 1.6,            // базовая толщина
    FIELD_SCALE: 0.0014,        // «ветер» для фонового движения
    DRAG: 0.06,                 // трение
    ZEN_PULL: 0.08,             // сила притяжения одного пальца
    ALL_PULL: 0.30,             // сила «собрать всё» (2 пальца)
    POLY_PULL: 0.22,            // сила к рёбрам многоугольника (3+ пальцев)
    EDGE_SNAP: 0.45,            // насколько сильно защёлкивать к рёбрам
    GLOW: 0.22,                 // свечение линий при рисовании
    BACK_FADE: 0.085,           // «шлейф» (0..1): больше — быстрее исчезает
    // Взрыв:
    EXP_MIN_HOLD: 10000,        // 10 секунд
    EXP_BASE: 12.0,             // основной импульс
    EXP_JITTER: 0.45,           // разброс направления
    EXP_SHOCK: 6.0,             // сила ударной волны
    EXP_DECAY: 0.13,            // насколько быстро затухает
  };

  // ---------- РАЗМЕР/ЧЁТКОСТЬ ----------
  let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
  function resize(){
    DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
    const { innerWidth:w, innerHeight:h } = window;
    canvas.width  = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width  = w+'px';
    canvas.style.height = h+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.imageSmoothingEnabled = false; // максимально резкие линии
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- УТИЛИТЫ ----------
  const rand = (a=0,b=1)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=> a + (b-a)*t;
  const TAU = Math.PI*2;
  function angle(x1,y1,x2,y2){ return Math.atan2(y2-y1, x2-x1); }

  // Псевдо-шум для фонового течения (быстрый, не «настоящий» Perlin)
  function hash(n){ n = Math.sin(n)*43758.5453; return n - Math.floor(n); }
  function noise2(x, y){
    const i = Math.floor(x), j = Math.floor(y);
    const a = hash(i + j*57), b = hash(i+1 + j*57), c = hash(i + (j+1)*57), d = hash(i+1 + (j+1)*57);
    const u = x - i, v = y - j;
    const ab = a + (b-a)*u;
    const cd = c + (d-c)*u;
    return ab + (cd-ab)*v;
  }

  // ---------- КАСАНИЯ/ЖЕСТЫ ----------
  const touches = new Map(); // id -> {x,y}
  let holdTimer = null, holdStart = 0, eligibleForExplosion = false;
  function updateTouches(ev){
    touches.clear();
    const pts = (ev.touches && ev.touches.length)? ev.touches : (ev.changedTouches||[]);
    for (let i=0;i<pts.length;i++){
      const t = pts[i];
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left);
      const y = (t.clientY - rect.top);
      touches.set(t.identifier ?? 0, { x, y });
    }
  }
  function pointerCount(){ return touches.size; }
  function centroid(){
    let sx=0, sy=0; for (const p of touches.values()){ sx+=p.x; sy+=p.y; }
    const n = Math.max(1,touches.size); return { x:sx/n, y:sy/n };
  }
  function orderedPolygon(){
    const arr = Array.from(touches.values());
    const c = centroid();
    arr.sort((a,b)=> Math.atan2(a.y - c.y, a.x - c.x) - Math.atan2(b.y - c.y, b.x - c.x));
    return arr;
  }

  canvas.addEventListener('touchstart', (ev)=>{
    ev.preventDefault();
    updateTouches(ev);
    if (pointerCount()===2){
      holdStart = performance.now();
      eligibleForExplosion = false;
      clearTimeout(holdTimer);
      holdTimer = setTimeout(()=>{ eligibleForExplosion = true; }, CFG.EXP_MIN_HOLD);
      // лёгкая вибрация при старте удержания
      navigator.vibrate?.(10);
    }
    hint.style.opacity = 0; // спрячем подсказку
  }, { passive:false });

  canvas.addEventListener('touchmove', (ev)=>{
    ev.preventDefault();
    updateTouches(ev);
  }, { passive:false });

  canvas.addEventListener('touchend', (ev)=>{
    ev.preventDefault();
    updateTouches(ev);
    if (pointerCount()<2 && eligibleForExplosion){
      triggerExplosion(); // отпустили после 10с — взрыв
    }
    if (pointerCount()<2){
      clearTimeout(holdTimer);
      eligibleForExplosion = false;
    }
  }, { passive:false });

  canvas.addEventListener('touchcancel', (ev)=>{
    updateTouches(ev);
    clearTimeout(holdTimer);
    eligibleForExplosion = false;
  }, { passive:false });

  // Поддержка мыши (для ПК)
  let mouseDown = false;
  canvas.addEventListener('mousedown', (e)=>{
    mouseDown = true;
    const rect = canvas.getBoundingClientRect();
    touches.set(0,{x:e.clientX-rect.left,y:e.clientY-rect.top});
  });
  window.addEventListener('mousemove', (e)=>{
    if (!mouseDown) return;
    const rect = canvas.getBoundingClientRect();
    touches.set(0,{x:e.clientX-rect.left,y:e.clientY-rect.top});
  });
  window.addEventListener('mouseup', ()=>{
    mouseDown = false; touches.clear();
  });

  // ---------- ЧАСТИЦЫ ----------
  const targetParticles = (()=> {
    const base = CFG.PARTICLES;
    const area = (innerWidth*innerHeight)/ (390*740); // грубая нормировка
    const mobileCap = /Mobi|Android/i.test(navigator.userAgent) ? 0.8 : 1.2;
    return Math.floor(base * clamp(area, .6, 2.2) * mobileCap);
  })();

  const P = [];
  function spawn(){
    P.length = 0;
    const { innerWidth:w, innerHeight:h } = window;
    for (let i=0;i<targetParticles;i++){
      P.push({
        x: rand(0,w), y: rand(0,h),
        vx: rand(-0.3,0.3), vy: rand(-0.3,0.3),
        hue: rand(0,360),
        life: rand(0,1)
      });
    }
  }
  spawn();

  // ---------- ВЗРЫВ ----------
  let explosion = null; // {cx,cy, t:0..1}
  function triggerExplosion(){
    const { x:cx, y:cy } = lastTwoCentroid();
    explosion = { cx, cy, t:0 };
    // мощный импульс + вибрации «удар»
    navigator.vibrate?.([8,30,14,30,8]);
    for (const p of P){
      const a = angle(cx,cy,p.x,p.y) + rand(-CFG.EXP_JITTER, CFG.EXP_JITTER);
      const dist = Math.hypot(p.x-cx, p.y-cy) + 1;
      const shock = CFG.EXP_SHOCK / Math.sqrt(dist);
      p.vx += Math.cos(a) * (CFG.EXP_BASE + shock);
      p.vy += Math.sin(a) * (CFG.EXP_BASE + shock);
      p.life = 0; // обновим цвет/яркость сразу после вспышки
    }
  }
  function lastTwoCentroid(){
    // если остался один палец на момент отпускания — берём последний известный центр
    const pts = Array.from(touches.values());
    if (pts.length>=2){
      const c = centroid(); return c;
    }
    // иначе центр экрана
    return { x: innerWidth/2, y: innerHeight/2 };
  }

  // ---------- РИСОВАНИЕ ----------
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  function drawTrailFade(){
    // аккуратное затухание шлейфа
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = CFG.BACK_FADE;
    ctx.fillStyle = '#0b0d10';
    ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    ctx.restore();
  }

  function strokeLine(x1,y1,x2,y2, w, h){
    // рисуем на полу-пиксель для острой линии
    ctx.beginPath();
    ctx.moveTo((x1|0)+0.5, (y1|0)+0.5);
    ctx.lineTo((x2|0)+0.5, (y2|0)+0.5);
    ctx.lineWidth = w;
    ctx.stroke();
  }

  function nearestPointOnSegment(px,py, ax,ay, bx,by){
    const abx = bx-ax, aby = by-ay;
    const apx = px-ax, apy = py-ay;
    const ab2 = abx*abx + aby*aby || 1e-6;
    let t = (apx*abx + apy*aby)/ab2;
    t = clamp(t, 0, 1);
    return { x: ax + abx*t, y: ay + aby*t, t };
  }

  function applyForces(dt){
    const pc = pointerCount();
    const { innerWidth:w, innerHeight:h } = window;

    for (const p of P){
      // фоновое поле — лёгкий «ветер»
      const a = noise2(p.x*CFG.FIELD_SCALE, p.y*CFG.FIELD_SCALE)*TAU*2;
      p.vx += Math.cos(a)*0.05;
      p.vy += Math.sin(a)*0.05;

      if (pc===1){
        // ZEN: плавное притяжение к одной точке
        const c = centroid();
        const dx = c.x - p.x, dy = c.y - p.y;
        p.vx += dx * CFG.ZEN_PULL * dt;
        p.vy += dy * CFG.ZEN_PULL * dt;
      } else if (pc===2){
        // СБОР ВСЕГО: в центр между пальцами
        const c = centroid();
        const dx = c.x - p.x, dy = c.y - p.y;
        p.vx += dx * CFG.ALL_PULL * dt;
        p.vy += dy * CFG.ALL_PULL * dt;
      } else if (pc>=3){
        // ГЕОМЕТРИЯ: защёлка к ребрам многоугольника
        const poly = orderedPolygon();
        const N = poly.length;
        // найдём ближайшую точку на любом ребре
        let best = null, bestD = Infinity, bestEdge = 0;
        for (let i=0;i<N;i++){
          const aPt = poly[i], bPt = poly[(i+1)%N];
          const proj = nearestPointOnSegment(p.x, p.y, aPt.x, aPt.y, bPt.x, bPt.y);
          const d = (p.x-proj.x)**2 + (p.y-proj.y)**2;
          if (d < bestD){ bestD=d; best=proj; bestEdge = i; }
        }
        // сила к ближайшей точке на ребре
        const pull = CFG.POLY_PULL;
        p.vx += (best.x - p.x) * pull * dt * (1 + CFG.EDGE_SNAP*0.5);
        p.vy += (best.y - p.y) * pull * dt * (1 + CFG.EDGE_SNAP*0.5);
        // лёгкая защёлка вдоль ребра (скользим к середине)
        const aPt = orderedPolygon()[bestEdge];
        const bPt = orderedPolygon()[(bestEdge+1)%N];
        const midx = (aPt.x + bPt.x)/2, midy = (aPt.y + bPt.y)/2;
        p.vx += (midx - p.x) * CFG.EDGE_SNAP * 0.06;
        p.vy += (midy - p.y) * CFG.EDGE_SNAP * 0.06;
      }

      // взрыв — радиальный импульс, быстрое затухание
      if (explosion){
        const {cx,cy,t} = explosion;
        const dx = p.x - cx, dy = p.y - cy;
        const dist = Math.hypot(dx,dy)+1;
        // ударная волна сильнее на близких
        const force = Math.max(0, 1 - t) * (CFG.EXP_SHOCK / Math.sqrt(dist));
        p.vx += (dx/dist) * force * 1.1;
        p.vy += (dy/dist) * force * 1.1;
      }

      // трение/границы
      p.vx *= (1 - CFG.DRAG);
      p.vy *= (1 - CFG.DRAG);
      p.x += p.vx; p.y += p.vy;

      // отскоки — чтобы взрыв «щелкал»
      if (p.x<0){ p.x=0; p.vx=Math.abs(p.vx); }
      if (p.y<0){ p.y=0; p.vy=Math.abs(p.vy); }
      if (p.x>w){ p.x=w; p.vx=-Math.abs(p.vx); }
      if (p.y>h){ p.y=h; p.vy=-Math.abs(p.vy); }

      // обновим «жизнь» для цвета
      p.life = (p.life + dt*0.8) % 1;
    }

    // управление временем взрыва
    if (explosion){
      explosion.t += CFG.EXP_DECAY;
      if (explosion.t>=1){ explosion = null; }
    }
  }

  function draw(dt){
    drawTrailFade();

    // мягкое свечение
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 18*CFG.GLOW;
    ctx.shadowColor = 'rgba(255,255,255,0.25)';
    for (const p of P){
      const speed = Math.hypot(p.vx, p.vy);
      const w = CFG.LINE_WIDTH * (1 + Math.min(1.7, speed*0.15));
      const nx = p.x + p.vx*0.8, ny = p.y + p.vy*0.8;

      // Цвет: радуга по углу + вспышка на взрыве
      const ang = Math.atan2(p.vy, p.vx);
      const baseHue = (ang*180/Math.PI + 360) % 360;
      const burstBoost = explosion ? (1 - explosion.t) : 0;
      const hue = (baseHue + 30*burstBoost) % 360;
      const sat = 70 + 30*burstBoost;
      const light = 55 + 20*Math.min(1, speed*0.07) + 10*burstBoost;
      ctx.strokeStyle = `hsl(${hue} ${sat}% ${light}%)`;

      strokeLine(p.x, p.y, nx, ny, w);
    }
    ctx.restore();

    // подсветка точек касания (минимальная, не мешает)
    if (touches.size){
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = 0.15;
      for (const t of touches.values()){
        const r = 40;
        const grd = ctx.createRadialGradient(t.x,t.y,0,t.x,t.y,r*2);
        grd.addColorStop(0, 'rgba(255,255,255,0.35)');
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(t.x,t.y,r*2,0,TAU); ctx.fill();
      }
      ctx.restore();
    }
  }

  // ---------- ЦИКЛ ----------
  let last = performance.now();
  function tick(now){
    const dt = clamp((now-last)/16.666, 0.5, 2.5);
    last = now;
    applyForces(dt);
    draw(dt);
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // авто-скрытие подсказки
  const hint = document.getElementById('hint');
  setTimeout(()=>{ hint.style.transition='opacity .5s ease'; hint.style.opacity=0; }, 3500);
})();
</script>
</body>
</html>
