<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Flow Field — Gestures Only</title>
  <meta name="theme-color" content="#070b11" />
  <style>
    :root{--bg:#070b11;--text:#e8eef5}
    *{box-sizing:border-box;}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 900px at 70% 10%, #0d1320 0%, #070b11 70%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;overscroll-behavior:none;touch-action:none}
    #c{position:fixed;inset:0;display:block}
    #grain{position:fixed;inset:0;pointer-events:none;opacity:.06;mix-blend-mode:overlay}
    .hint{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);font-size:14px;letter-spacing:.2px;color:#a9b4c4;background:#0d1421cc;border:1px solid #1b2636;border-radius:16px;padding:10px 12px;backdrop-filter:blur(8px);box-shadow:0 12px 30px rgba(0,0,0,.35);opacity:.95;transition:opacity .6s ease}
    .hidden{opacity:0}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <canvas id="grain"></canvas>
  <div class="hint" id="hint">1 палец — мягко веди линии · 2 пальца — собрать всё (удержи ≥10с, отпусти → взрыв) · 3+ пальцев — геометрические фигуры</div>

<script>
// ---------- utils ----------
const rand=(a=1,b=0)=>a+(b-a)*Math.random();
const clamp=(x,min,max)=>Math.min(max,Math.max(min,x));
const lerp=(a,b,t)=>a+(b-a)*t;
const TAU=Math.PI*2, RAD=180/Math.PI;
const hsla=(h,s,l,a=1)=>`hsla(${h},${s}%,${l}%,${a})`;

// ---------- noise ----------
class SimplexNoise{constructor(r=Math){this.p=new Uint8Array(256);for(let i=0;i<256;i++)this.p[i]=i;for(let i=255;i>0;i--){const n=r.random()*(i+1)|0;const q=this.p[i];this.p[i]=this.p[n];this.p[n]=q}this.perm=new Uint8Array(512);for(let i=0;i<512;i++)this.perm[i]=this.p[i&255];}
  noise2D(xin,yin){const g=new Float32Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);const F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6;let n0=0,n1=0,n2=0;const s=(xin+yin)*F2;const i=Math.floor(xin+s),j=Math.floor(yin+s);const t=(i+j)*G2;const X0=i-t,Y0=j-t;const x0=xin-X0,y0=yin-Y0;let i1,j1;if(x0>y0){i1=1;j1=0}else{i1=0;j1=1}const x1=x0-i1+G2,y1=y0-j1+G2,x2=x0-1+2*G2,y2=y0-1+2*G2;const ii=i&255,jj=j&255;const gi0=this.perm[ii+this.perm[jj]]%12*2,gi1=this.perm[ii+i1+this.perm[jj+j1]]%12*2,gi2=this.perm[ii+1+this.perm[jj+1]]%12*2;let t0=0.5-x0*x0-y0*y0;if(t0>=0){t0*=t0;n0=t0*t0*(g[gi0]*x0+g[gi0+1]*y0)}let t1=0.5-x1*x1-y1*y1;if(t1>=0){t1*=t1;n1=t1*t1*(g[gi1]*x1+g[gi1+1]*y1)}let t2=0.5-x2*x2-y2*y2;if(t2>=0){t2*=t2;n2=t2*t2*(g[gi2]*x2+g[gi2+1]*y2)}return 70*(n0+n1+n2)} }

// ---------- canvas ----------
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d',{alpha:false});
const grainCanvas=document.getElementById('grain');
const gctx=grainCanvas.getContext('2d');
let DPR=Math.min(2,window.devicePixelRatio||1);
function resize(){const W=Math.floor(innerWidth*DPR),H=Math.floor(innerHeight*DPR);canvas.width=W;canvas.height=H;canvas.style.width=innerWidth+'px';canvas.style.height=innerHeight+'px';ctx.setTransform(1,0,0,1,0,0);ctx.scale(DPR,DPR);grainCanvas.width=W;grainCanvas.height=H;grainCanvas.style.width=innerWidth+'px';grainCanvas.style.height=innerHeight+'px';drawGrain();}
addEventListener('resize',resize);resize();
function drawGrain(){const img=gctx.createImageData(grainCanvas.width,grainCanvas.height);for(let i=0;i<img.data.length;i+=4){const v=200+(Math.random()*55)|0;img.data[i]=img.data[i+1]=img.data[i+2]=v;img.data[i+3]=255;}gctx.putImageData(img,0,0)}

// ---------- simulation ----------
const noise=new SimplexNoise();
const isMobile=/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
let particles=[]; const params={count:isMobile?3000:5500, speed:2.0, thick:1.15, scale:480, hue:210};
let frame=0, seed=Math.random()*1000;

class Particle{constructor(){this.reset(true);}reset(rnd=false){this.x=rnd?rand(0,innerWidth):innerWidth/2;this.y=rnd?rand(0,innerHeight):innerHeight/2;this.vx=0;this.vy=0;this.life=rand(140,420);this.age=0;this.h=rand(0,360);}step(){this.age++; if(this.age>this.life) this.reset(true);
  const n=noise.noise2D((this.x+seed)/params.scale,(this.y-seed)/params.scale); const a=n*TAU + frame*0.002;
  let ax=Math.cos(a)*0.16, ay=Math.sin(a)*0.16; // base flow

  // gesture forces
  applyForces(this, ax, ay);

  const damp=0.90; this.vx=(this.vx+ax)*damp; this.vy=(this.vy+ay)*damp;
  const spd=params.speed*0.82; this.x+=this.vx*spd; this.y+=this.vy*spd;
  if(this.x<0)this.x+=innerWidth; if(this.x>innerWidth)this.x-=innerWidth; if(this.y<0)this.y+=innerHeight; if(this.y>innerHeight)this.y-=innerHeight;}}

function rebuild(){const t=params.count|0; if(t>particles.length){for(let i=particles.length;i<t;i++)particles.push(new Particle());}else particles.length=t;}
rebuild();

// ---------- gestures ----------
const touches=new Map(); // id -> {x,y,t}
let gestureStartTime=0; let heldTwoFinger=false; let explosionArmed=false; let lastMode='';
let explosionUntil=0; let explosionColorBoost=0; let explosionPoint={x:0,y:0};

function updateModeFeedback(mode){ if(mode!==lastMode){ if(navigator.vibrate) navigator.vibrate(12); lastMode=mode; }}

function centroid(points){ let sx=0,sy=0; for(const p of points){sx+=p.x; sy+=p.y;} return {x:sx/points.length, y:sy/points.length}; }

function polySort(points){ const c=centroid(points); return [...points].sort((a,b)=>Math.atan2(a.y-c.y,a.x-c.x)-Math.atan2(b.y-c.y,b.x-c.x)); }

function applyForces(p, ax, ay){ const now=performance.now(); const pts=[...touches.values()]; const k=pts.length;
  // explosion force override
  if(now<explosionUntil){ const dx=p.x-explosionPoint.x, dy=p.y-explosionPoint.y; const d=Math.hypot(dx,dy)||1; const f=3.5*Math.exp(-d/260); p.vx+= (dx/d)*f + (rand(-0.5,0.5)); p.vy+= (dy/d)*f + (rand(-0.5,0.5)); return; }

  if(k===0){ return; }
  if(k===1){ // one finger: calm attraction, local falloff
    updateModeFeedback('one');
    const t=pts[0]; const dx=t.x-p.x, dy=t.y-p.y; const d=Math.hypot(dx,dy)||1; const f=1.1*Math.pow(1-Math.min(1,d/180),2.2); p.vx+= (dx/d)*f; p.vy+= (dy/d)*f; return; }
  if(k===2){ // two fingers: gather all to mid
    updateModeFeedback('two');
    const mid=centroid(pts); const dx=mid.x-p.x, dy=mid.y-p.y; const d=Math.hypot(dx,dy)||1; const f=1.8; p.vx+= (dx/d)*f; p.vy+= (dy/d)*f; return; }
  // 3+ fingers: geometric figure
  updateModeFeedback('poly');
  const ordered=polySort(pts); const c=centroid(ordered); // pull towards nearest vertex and edge
  let nearest=ordered[0]; let best=Infinity; for(const v of ordered){ const dd=(v.x-p.x)**2+(v.y-p.y)**2; if(dd<best){best=dd; nearest=v;} }
  // attraction to nearest vertex
  let dx=nearest.x-p.x, dy=nearest.y-p.y; let d=Math.hypot(dx,dy)||1; let f=1.6*Math.pow(1-Math.min(1,d/220),2.0); p.vx+= (dx/d)*f; p.vy+= (dy/d)*f;
  // and slight pull towards polygon center for cohesion
  dx=c.x-p.x; dy=c.y-p.y; d=Math.hypot(dx,dy)||1; f=0.6; p.vx+= (dx/d)*f; p.vy+= (dy/d)*f;
}

// timers for 2-finger hold
function checkTwoFingerHold(){ const now=performance.now(); if(touches.size===2){ if(!heldTwoFinger){ heldTwoFinger=true; gestureStartTime=now; explosionArmed=false; } else {
    const dur=now-gestureStartTime; if(dur>=10000){ explosionArmed=true; } }
  } else { heldTwoFinger=false; }}

function triggerExplosion(point){ explosionPoint={...point}; explosionUntil=performance.now()+2600; explosionColorBoost=1; if(navigator.vibrate) navigator.vibrate([10,40,10]); }

addEventListener('pointerdown',e=>{touches.set(e.pointerId,{x:e.clientX,y:e.clientY,t:performance.now()}); checkTwoFingerHold(); hideHintSoon();});
addEventListener('pointermove',e=>{if(touches.has(e.pointerId)){ const t=touches.get(e.pointerId); t.x=e.clientX; t.y=e.clientY; }});
addEventListener('pointerup',e=>{
  const wasTwo=touches.size===2; const pts=[...touches.values()];
  touches.delete(e.pointerId);
  if(wasTwo && explosionArmed){ // only when two-finger and held >=10s
    const mid=centroid(pts); triggerExplosion(mid);
  }
  checkTwoFingerHold();
});
addEventListener('pointercancel',e=>{touches.delete(e.pointerId); checkTwoFingerHold();});

// ---------- drawing ----------
function loop(){ requestAnimationFrame(loop); frame++;
  ctx.globalCompositeOperation='source-over'; ctx.fillStyle='rgba(11,15,20,0.06)'; ctx.fillRect(0,0,innerWidth,innerHeight);

  // subtle focus glow at centroid when any touches
  const pts=[...touches.values()]; if(pts.length>0){ const c=centroid(pts); const r=Math.min(innerWidth,innerHeight)*0.08; const g=ctx.createRadialGradient(c.x,c.y, r*0.2, c.x,c.y, r);
    g.addColorStop(0,'rgba(120,231,255,0.10)'); g.addColorStop(1,'rgba(167,139,250,0.02)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(c.x,c.y,r,0,TAU); ctx.fill(); }

  ctx.globalCompositeOperation='lighter'; ctx.lineCap='round'; ctx.lineWidth=params.thick;
  const hueBase=params.hue; const now=performance.now();
  for(let i=0;i<particles.length;i++){
    const p=particles[i]; const x0=p.x,y0=p.y; p.step();
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(p.x,p.y);

    // color logic
    let h=(hueBase+(i*0.03+frame*0.08))%360; let s=80, l=60, a=0.55;
    if(touches.size>=3){ // color by nearest touch angle
      const pts=[...touches.values()]; let nearest=pts[0]; let best=Infinity; for(const t of pts){ const d=(t.x-p.x)**2+(t.y-p.y)**2; if(d<best){best=d; nearest=t;} }
      const ang=((Math.atan2(nearest.y-p.y, nearest.x-p.x)*RAD)+360)%360; h = (h*0.5 + ang*0.5)%360; s=85; a=0.6;
    } else if(touches.size===2){ h=(h+20)%360; s=90; a=0.65; }

    // explosion color boost
    if(now<explosionUntil){ s=100; l=55; a=0.7; }

    ctx.strokeStyle=hsla(h,s,l,a); ctx.stroke();
  }
}

// hint fade
const hint=document.getElementById('hint');
let hintTimer=setTimeout(()=>hint.classList.add('hidden'), 5500);
function hideHintSoon(){ clearTimeout(hintTimer); hintTimer=setTimeout(()=>hint.classList.add('hidden'), 1800); }

// start
loop();
</script>
</body>
</html>
